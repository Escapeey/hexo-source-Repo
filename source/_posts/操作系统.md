---
title: 操作系统
date: 2023-11-02 09:10:22
tags:
---
# 操作系统概述
## 操作系统定义
**操作系统**：是管理计算机系统资源、控制程序执行、改善人机界面和为应用软件提供支持的一种系统<font color=red>软件</font>。
### 多道程序设计：
现代操作系统一般都采用多道程序设计技术，其基本思想是在主存中同时存放多个用户的作业，使之同时处于运行状态而共享系统资源。

多道程序设计——多个程序同时进入主存并发执行。

## 操作系统的作用
### OS作为用户与计算机硬件系统之间的接口
- OS是一个系统软件，因而这种接口是**软件接口**。
### OS作为计算机系统资源的管理者
OS的**主要功能**为:
- **处理机管理**：用于分配和控制处理机；
- **存储器管理**：主要负责内存的分配与回收；
- **I/O设备管理**：负责I/O设备的分配与操纵；
- **文件管理**：负责文件的存取、共享和保护。可见，OS确是计算机系统资源的管理者。 
### OS实现了对计算机资源的抽象
- 通常把覆盖了软件的机器称为扩充机器或虚机器。
## 操作系统的基本特性
### 并发
- **并行性**：指两个或多个事件在同一时刻发生
- **并发性**：指两个或多个事件在同一时间间隔内发生
    - 在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。
### 共享
- **共享**的概念：指系统中的资源，可供内存中多个并发执行的进程(线程)共同使用 。
- 进程对资源共享的方式：
    - **互斥共享**：当某一进程访问完并释放该资源后，才允许另一进程进行访问。这种资源称为<font color=red>临界资源</font>或独占资源,如打印机；
    - **同时共享**：允许在一段时间内由多个进程同时访问，如磁盘设备
### 虚拟
#### 定义
- 操作系统中的所谓“**虚拟**”，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。
- 在OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存(设置：我的电脑、属性、高级、性能选项)、 虚拟外部设备(虚拟光驱、盘符D：等)和虚拟信道等。
#### OS中采用的2种虚拟技术
- **时分复用技术** -多设备分时使用物理设备
    - 利用该技术可以实现虚拟处理机、虚拟设备等，以**提高资源利用率**。
    - 虚拟处理机：是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一台处理机的。
    - 虚拟设备技术：将一台物理I/O设备虚拟为多台逻辑上的I/O设备。 如虚拟打印机。
- **空分复用技术** 
    - 利用该技术可以实现虚拟磁盘技术、虚拟存储器技术等，以**提高存储空间利用率**。
    - 虚拟磁盘技术：一个硬盘划分为1、2、3、4四个卷，分别安装在C、D、E、F四个逻辑驱动器上，成为四个虚拟磁盘。
    - 虚拟存储器技术：一个100M的程序可以运行在20M的内存空间

### 异步性
- 在多道程序环境下，允许多个进程并发执行。使进程的执行是以“走走停停”的方式运行；
- **进程的异步性**: 每个程序在何时执行，多个程序间的执行顺序以及完成每道程序所需的时间都是不确定和不可预知的。进程是以人们不可预知的速度向前推进
## 操作系统结构设计 
- 第一代：无结构OS；
- 第二代：模块化结构OS；
- 分层式操作系统；
### 模块化结构OS
- 模块之间直接调用函数，除了函数调用的开销外，没有额外开销
- 庞大的操作系统有数以千计的函数
### 微内核(Micro Kelnel)结构OS -现代结构
#### 微内核技术
- **微内核技术**: 指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同，它更小更精炼，它不仅运行在核心态，而且**开机后常驻内存**。
- 微内核**并非**是一个完整的OS， 而只是为构建通用OS提供一个重要基础。在微内核OS结构中，通常都采用了**客户/服务器模式**。
<img src="..\img\OS\os微内核.png" width="70%" height="70%" align="middle">

- **优缺点**
    - 内核与各个服务器之间通过通信机制进行交互，这使得微内核结构的效率大打折扣
    - 因为各个服务器模块的相对独立性，使得其维护相对容易。
#### 客户/服务器模式
客户/服务器系统主要由**客户机**、**服务器**和**网络系统**三个部分组成。
- 客户机：平时处理本地业务，也可发送一个消息给服务器，以请求某项服务
- 服务器：通常是一台规模较大的机器，在其上驻留有网络文件系统或数据库系统等，为用户提供多种服务。
#### 面向对象的程序设计技术
- 在OS中的各类实体如进程、线程、消息、存储器和文件等，都使用了对象这一概念，相应地，便有了进程对象、线程对象、存储器对象和文件对象等
- 操作系统是一个极其复杂的大型软件系统，面向对象技术被广泛应用于现代操作系统的设计中。 
#### 微内核的基本功能
通常都是一些最基本的功能：
- 进程(线程)管理。 
- 低级存储器管理。 
- 中断和陷入处理。   
将OS中**最基本**的部分放入内核中，而把OS的**绝大部分功能**放在微内核**外面的一组服务器（进程）**中实现。     
#### 微内核操作系统存在的问题
微内核OS的**运行效率有所降低：**
    会引起更多的上下文切换。例如某个服务器自身尚无能力完成客户请求，而需其它服务器帮助时，如图1-11中所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行八次上下文的切换。 
<img src="..\img\OS\os微内核缺点.png" width="70%" height="70%" align="middle">

# 进程管理
## 进程的描述与控制
### 程序的顺序执行及其特征
程序顺序执行时的特征:
- **顺序性**: 按照程序结构所指定的次序
- **封闭性**: 运行时候独占处理机资源，运行结果不受外界影响
- **可再现性**: 初始条件相同，结果相同
### 程序的并发执行及其特征
**定义**：程序的并发执行是指一组在逻辑上互相独立的程序或程序段在执行时间上客观上互相重叠，即一个程序或程序段的执行尚未结束，另一个程序（段）的执行已经开始的执行方式
程序并发执行时的特征:
- **间断性(相互制约性)**:－ “走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；
- **失去封闭性**：多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变, 致使程序的运行已失去了封闭性。
- **不可再现性**：程序在并发执行时，由于失去了封闭性，也将导致失去其可再现性

### 进程
#### 进程的定义
- 简：进程是程序的一次执行；
- 详：一个具有一定独立功能的**程序**在一个**数据集合**上的一次**动态执行**过程
- 进程是系统进行**资源分配和调度**的一个**独立单位**
#### 进程的特征
- **动态性**:
    - 进程是程序产生的：创建->运行->消亡
    - 进程在生命周期中在三种基本状态之间转换
- **独立性**:
    各进程的**地址相互独立**，除非采用进程间通信手段
- **并发性**:
    多个进程实体同时存于内存中，能在一段时间内并发进行
- **异步性**:
    每个进程都以其相对独立的不可预知的速度向前推进
- **结构化**:
    进程 = 代码块 + 数据块 + **PCB**
#### 进程的组成
**进程 = 程序 + 数据 + 进程控制块PCB**
- **程序**是进程的不可缺少的组成部分；如果一个程序段允许被共享，则它应该是可重入的，或纯代码段
- **数据**是进程处理的对象
- **进程控制块**是进程的**控制结构**，包含了进程的**描述信息**、**控制信息**和**资源信息**以及**现场保护区**，是进程的<font color=red>**唯一标识**</font>，系统通过PCB管理和控制进程。

#### 进程控制块PCB
- 进程控制块是由OS维护的用来记录进程相关信息和管理进程而设置的一个专门的**数据结构**
- PCB结构的全部或部分**常驻内存**；
- PCB随进程的创建而填写，随进程的撤消而释放,有生命周期；
- 系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志
- 进程与PCB是一一对应的
- **OS是根据PCB来对并发执行的进程进行控制和管理的。**
- **所谓创建进程是指创建进程实体中的PCB，撤销亦如此。**
##### PCB的内容
- **进程标识符**: 
    - 内部进程标识符(process ID)，唯一，通常是一个整数
    - 进程名(外部标识符)，通常基于可执行文件名（不唯一）
    - 用户标识符(user ID)；进程组关系(process group)
- **进程调度信息**：
    进程状态、进程优先级、资源信息等
- **处理机状态**：
    寄存器值（通用、程序计数器PC、状态PSW，地址包括栈指针）
- **进程控制信息**:
    - 当前状态；
    - 优先级(priority)；
    - 代码执行入口地址；
    - 程序的外存地址；
    - 运行统计信息（执行时间、页面调度）；
    - 进程间同步和通信；阻塞原因
##### PCB的组织方式
- **链表**：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表
    - 各状态的进程形成不同的链表：就绪链表、阻塞链表
- **索引表**：同一状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表
    - 各状态的进行形成不同的索引表：就绪索引表、阻塞索引表
#### 进程与程序的区别
- 进程是动态的，程序是静态的：炒菜菜谱
- 进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存。
- 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）。
- 进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。
- 进程具有并行特征，程序没有。
- 进程是竞争计算机资源的基本单位。
### 进程的状态及其转换
#### 进程的三种基本状态
- **就绪状态(Ready)**：已分配到**除CPU以外**的所有必要的资源，只要能再获得处理机，便可立即执行的状态。多个排成一队称为就绪队列。 
- **执行状态(Running)**：指进程已获得处理机，其程序正在执行;
    - 在单处理机系统中，只能有一个进程处于执行状态;
    - 在多处理机系统中，则可能多个进程处于执行状态。  
- **阻塞状态(Blocked)**：进程因**发生某事件**(如请求I／O、申请缓冲空间等)而暂停执行时的状态，亦即进程的执行受到阻塞，故称这种暂停状态为阻塞状态，有时也称为“等待”状态或“睡眠”状态。
    - 通常将处于阻塞状态的进程排成一个队列，称为阻塞队列。在有的系统中，按阻塞原因的不同而将处于阻塞状态的进程排成多个队列。
#### 进程的三种基本状态转换
<img src="..\img\OS\进程三状态.png" width="70%" height="70%" align="middle">

- **就绪->运行**：调度程序选择一个新的进程运行
- **运行->就绪**：
    - 运行进程用完了时间片
    - 运行进程被中断，因为一高优先级进程处于就绪状态
- **运行->等待**：当一进程等待某一事件的发生时，如
    - 请求系统服务
    - 无新工作可做
- **等待->就绪**：当所等待的事件发生时

#### 进程的五状态进程转换
<img src="..\img\OS\进程五状态.png" width="70%" height="70%" align="middle">

- **创建状态(New)**：创建新状态
    - OS 已完成为创建一进程所必要的工作
        - 已构造了进程标识符
        - 已创建了管理进程所需的表格
- **终止状态(Exit)**
    - 终止后进程移入该状态
    - 它不再有执行资格
    - 表格和其它信息暂时保留
    - 实用程序为了分析性能和利用率，可能要提取程序的历史信息
#### 带挂起的进程转换模型
##### 新增状态
- **就绪挂起状态(Ready,suspend)**：进程在外存，但只要进入内存，即可运行；
- **阻塞挂起状态(Blocked,suspend)**：进程在外存并等待某事件的出现；
##### 新增事件
- **挂起(Suspend)**：把一个进程从内存转到外存；可能有以下几种情况：
    - **阻塞到阻塞挂起**：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以纳入新进程或运行就绪进程；
    - **就绪到就绪挂起**：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程；
    - **运行到就绪挂起**：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；
- **激活(Activate)**：把一个进程从外存转到内存；可能有以下几种情况：
    - **就绪挂起到就绪**：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；
    - **阻塞挂起到阻塞**：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转为阻塞状态；较少出现。
- **事件出现(Event Occurs)**：进程等待的事件出现；如：操作完成、申请成功等；可能的情况有：
    - **阻塞到就绪**：针对内存进程的事件出现；
    - **阻塞挂起到就绪挂起**：针对外存进程的事件出现；
- **收容(Admit)**：收容一个新进程，进入就绪状态或就绪挂起状态。
- **各种状态->退出**：被父进程终止或父进程本身终止。


##### 挂起进程目的是:
- **提高处理机效率**：就绪进程表为空时，OS将阻塞进程从内存中“挂起”到磁盘的“挂起队列”，再从该队列选另一进程进入内存，或接受一个新进程的请求。
- **为运行进程提供足够内存**：资源紧张时，暂停某些进程，如：CPU繁忙（或实时任务执行）,内存紧张
- **用于调试**：在调试时，挂起被调试进程（从而对其地址空间进行读写）
##### 单挂起进程模型
<img src="..\img\OS\单挂起进程模型.png" width="70%" height="70%" align="middle">

##### 双挂起进程模型
<img src="..\img\OS\双挂起进程模型.png" width="70%" height="70%" align="middle">

### 进程控制的功能
#### 原语(primitive)
- 由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割－－要么全都完成，要么全都不做。许多系统调用就是原语。
#### 进程创建原语
子进程的创建的3种形式
|  | 产生新进程 | 不产生新进程 |
|:-:|:-------:|:-----------:|
|复制现有进程的上下文|**fork**(新进程的系统上下文会有不同)|   |
|加载程序|**spawn**(创建新进程并加载新程序) |**exec**(加载新程序并覆盖自身)|
#### 进程撤销原语
**Destroy**
- 释放资源：
    - 释放内外存空间
    - 关闭所有打开文件
    - 释放共享内存段和各种锁定lock
#### 进程阻塞原语
**Block**
- 阻塞原因：当进程期待的某事件尚未出现时，该进程调用阻塞原语把自己阻塞起来
- 进程的阻塞是进程自身的一种主动行为
#### 进程唤醒原语
**Wakeup**
- 唤醒原因：
    - 进程等待的事件发生，等待队列中的进程唤醒。
- 唤醒进程的两种方法：
    - **由系统进程唤醒**: 系统进程统一控制事件的发生，并将“事件发生”这一消息通知等待进程。等待的是公共资源。
    - **由事件发生进程唤醒**: 事件发生进程与被唤醒的进程是合作关系，等待私有资源。
#### 进程挂起原语
**Suspend**
- 引起进程挂起的事件:
    - 用户进程请求将自己挂起;
    - 或父进程请求将自己的某个子进程挂起，
    - 系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。
#### 进程激活原语
**Active**
- 进程的激活过程
    - 系统将利用激活原语active( )将指定进程激活。 激活原语先将进程从外存调入内存，检查该进程的现行状态，若是就绪挂起，便将之改为活动就绪；若为阻塞挂起便将之改为活动阻塞。


## 进程同步
### 1.一组并发进程执行时存在两种相互制约关系： 
- **进程互斥** (打印机)
    - **资源共享关系**（间接相互制约关系） 
    - 进程本身之间**不存在直接联系**。
    - 例如:在仅有一台打印机的系统中，有两个进程A和B，如果在A进程提出打印请求时，系统已将打印机分配给进程B，则系统让A进程等待，直至B将打印机用完并释放后，系统才将打印机分配给进程A。
- **进程同步** (接力棒)
    - **相互合作关系**（直接相互制约关系）
    - 进程本身之间**存在着相互制约的关系**。
    - 例如：有一输入进程A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程B因不能获得所需数据而等待。当进程A把数据送入缓冲时，便应向进程B发送一信号，将它唤醒
### 2.临界资源
- 临界资源: 在一段时间内只允许**一个进程访问**的资源。诸进程间应采取**互斥方式**，实现对资源的共享。
- 共享变量，打印机 等均属于此类资源。

### 3.临界区
#### 临界区的定义与进入
- **临界区**(critical section)：
    在每个进程中访问临界资源的那段代码
- **进入区**：
    在临界区前面增加一段用于进行临界资源检查的代码
- **退出区**：
    将临界区正被访问的标志恢复为未被访问的标志。
- **剩余区**：其余部分。
#### 使用临界区遵循的原则
- **空闲则入**：其他进程均不处于临界区；
- **忙则等待**：已有进程处于其临界区；
- **有限等待**：等待进入临界区的进程不能"死等"；
- **让权等待**：不能进入临界区的进程，应释放CPU(如转换到阻塞状态)
#### 解决诸进程互斥进入临界区的方法
- 硬件同步机制
- 软件同步机制

### 4.硬件同步机制
目的：解决诸进程互斥进入临界区。
目前许多计算机已提供了一些特殊的硬件指令来解决临界区问题。
- 关中断；
    - 关中断是实现互斥的最简单的方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。
    - 关中断的方法存在许多缺点：
        - 滥用关中断权力可能导致严重后果；
        - 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；
        - 关中断方法也不适用于多CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。
- 利用Test-and-Set指令实现互斥；
- 利用Swap指令实现进程互斥；

### 5.软件同步机制(进程互斥的软件方法)
#### 利用信号量机制实现进程互斥

### 6.管程(monitor)






## 进程通信及线程

## 处理机调度与死锁--完成进程状态的转换

# 存储器管理
存储管理是指存储器资源（主要指内存并涉及外存）的管理。
- **存储器资源的组织**（如内存的组织方式）
- **地址变换**（逻辑地址与物理地址的对应关系维护）
- **虚拟存储的调度算法**

## 存储管理的功能
1. **主存分配和回收**
    分配和回收算法及相应的数据结构。
2. **地址变换**
    - 可执行文件生成中的链接技术
    - 程序加载(装入)时的重定位技术
    - 进程运行时硬件和软件的地址变换技术和机构
3. **存储共享和保护**
    - 代码和数据共享
    - 地址空间访问权限（读、写、执行）
4. **主存容量扩充**(存储器的逻辑组织和物理组织)
    - 由应用程序控制：覆盖；
    - 由OS控制：交换（整个进程空间），虚拟存储的请求调入和预调入（部分进程空间）
    - 提高主存利用率

## 程序的装入和链接 
### 程序的装入(重定位)(地址映射)
#### 重定位
- **重定位**: 程序运行装入主存时，要将程序中的虚拟地址转换为主存中的物理地址，这个转化过程就是重定位。
- 程序成为进程前的准备工作:
    - **编辑**：形成源文件(符号地址)
    - **编译**：形成目标模块(模块内符号地址解析)
    - **链接**：由多个目标模块或程序库生成可执行文件(模块间符号地址解析)
    - **装入**：构造PCB，形成进程(使用物理地址)
#### 重定位方法
##### 可重定位装入(静态重定位)
- 内容
    - 编写程序时可以采用相对地址
    - 作业（用户程序）在装入内存时才确定它的物理地址，并且将相对地址转换为物理地址
    - 作业一旦装入就不能移动、改变空间或者被换出主存。
    - 在程序运行之前，由**链接**装入程序进行的一次重定位。
    - 在程序运行之前已经**完成了逻辑地址到物理地址的转换**(只要完成链接装入)
- 优点：**不需硬件变换机构**支持，可以装入有限多道程序
- 缺点：一个程序通常需要占用连续的内存空间，程序装入内存后**在运行期间不能移动**，不易实现共享。

##### 动态运行时装入(动态重定位)
- 内容
    - 动态重定位是在程序**执行的过程**中，每当访问指令或数据时，才将要访问的**指令或数据**的**逻辑地址转换成物理地址**。
    - 在程序**装入时不对地址做任何操作**，也就是保留逻辑地址不变。
    - **运行时重定位**：可以使程序载入后还可以移动
    - 每个进程有各自的**基地址,放在PCB**


## 连续分配方式
### 分配方式
- **固定分区**: 把内存划分为若干个固定大小的连续分区。
    - 分区大小可以相等也可以不同
    - **固定分区可能存在内碎片**
    - 系统通过**分区说明表**对内存进行管理和控制。

- **动态分区**：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。
    - 没有内碎片；有外碎片，如果大小不是任意的，也可能出现内碎片。
    - **内存紧缩**：将空闲分区合并，需要移动多个段(复制内容)：

### 分区分配数据结构
#### 空闲分区表
- 用于为内存中每个**尚未分配**的分区设置一个表项，每个分区的表项包含**分区序号**、**分区始址**及**分区大小**；
#### 空闲分区链
- 通过前、后向指针将所有的分区链接成一个双向链

### 分区分配算法
#### 首次适应算法FF
1. 内容
内存分配时，从**链首开始顺序查找**，直至找到一个能满足其大小要求的空闲分区为止。然后按作业大小划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。
2. 优点
    - 优先利用内存中**低址**部分的空闲分区，在**高址**部分的空闲分区很少被利用，从而保留了高址部分的大空闲区，为后到的大作业分配大的内存空间创造了条件。
3. 缺点
    - **低址部分不断被划分**，形成碎片；
    - 每次查找都从低址部分开始，这**增加了查找可用空闲分区的开销**。
#### 循环首次适应算法
1. 内容
    - 内存分配时，从**上次找到的空闲分区的下一个空闲分区**开始查找，直至找到第一个能满足要求的空闲分区，并从中划出一块与请求的大小相等的内存空间分配给作业
    - 设置一起始查寻指针，并采用**循环查找**方式。
2. 优点
    - 使内存中的空闲分区分布得更均匀
    - 减少查找空闲分区的开销
3. 缺点
    - 缺乏大的空闲分区
#### 最佳适应算法
1. 内容
    - “最佳”是指每次为作业分配内存时，总把**既能满足要求**、**又是最小**的空闲分区分配给作业，避免了“大材小用”。
    - 为了加速寻找，该算法要求将所有的空闲区，**按其大小以递增**的顺序形成**空闲区链**。

### 分区分配和回收操作
#### 动态分区分配内存 
> - 首先系统要利用某种分配算法，从空闲分区链(表)中找到所需的分区;
> - 设**请求的分区大小为u.size**，表中每个空闲分区的大小可表示为m.size;
> - if(**m.size-u.size<=size**)
    - // size是事先规定的不再切割的剩余分区的大小
    - 说明多余部分太小,可不再切割，**将整个分区分配给请求者**;
> - else
    - 从该分区中划分出与请求的大小相等的内存空间分配出去，余下的部分仍留在空闲分区链或空闲分区表中。最后，将分配区的首址返回给调用者;
#### 回收内存
##### 内存紧缩
- 内容：将各个占用分区向内存一端移动。使各个空闲分区聚集在另一端，然后将各个空闲分区合并成为一个空闲分区。
- 这过程涉及到了**动态重定位**
- 紧缩时机：每个分区释放后，或内存分配找不到满足条件的空闲分区时

#### 可重定位分区分配(增加了内存紧凑)
<img src="..\img\OS\动态重定位分区分配算法.png" width="70%" height="70%" align="middle">

### 对换
#### 对换的定义
- 指把内存中**暂时不能运行的进程**或者**暂时不用的程序和数据**，调出到**外存**上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存
- 对换是提高内存利用率的有效措施
- 整体对换(进程对换): 对换是以整个进程为单位
- 部分对换(页面对换/分段对换): 对换是以“**页**”或“**段**”为单位进行
- 为了实现进程对换，系统必须能实现三方面的功能：
    - 对换空间的管理
    - 进程的换出
    - 进程的换入
#### 对换空间的管理
- 数据结构: 空闲分区表或空闲分区链
- **空闲分区表**中的每个表目中应**包含两项**， 即**对换区**的**首址**及其**大小**，它们的单位是**盘块号**和**盘块数**。 
> **外存空间分类**
**文件区**：用于**存放文件**，由于通常的文件都是较长久地驻留在外存上，故对文件区管理的主要目标是**提高文件存储空间的利用率**，为此系统采取**离散分配**方式。
**对换区**：用于**存放从内存换出的进程**，由于这些进程在对换区中驻留的时间是短暂的，而对换操作又较频繁，故对对换空间管理的主要目标是**提高进程的换入、换出速度**，为此所应采取的管理策略是**用连续分配方式**，较少考虑外存中的碎片问题。
#### 进程的换出与换入
##### 进程的换出
- 每一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出
- 换出过程:
    - 系统首先选择处于**阻塞状态**且**优先级最低**的进程作为换出进程;
    - 启动盘块，将该进程的程序和数据传送到磁盘的对换区上;
    - 若传送过程未出现错误，便可**回收该进程所占用的内存空间**，并对该进程的PCB做相应的修改。 
##### 进程的换入
- 系统应**定时地查看**所有进程的状态;
- 从中找出“**就绪**”状态但已换出的进程，将其中**换出时间(换出到磁盘上)最久的进程**作为换入进程，将之换入;
- 直至已无可换入的进程或无可换出的进程为止。 

## 离散分配方式
- 思想：将**一个进程**直接**分散地分配到许多不相邻接的分区中**，就不必再进行“紧凑”。
- 离散分配种类：
    - 分页存储管理 
    - 分段存储管理 
    - 段页式存储管理 
## 基本分页存储管理方式 
### 页面和物理块
- **页面**: 
    - 将一个进程的**逻辑地址空间**分成若干个**大小相等**的片，称为**页面**或**页**，并为各页加以编号，从0开始，如第0页、第1页等。
- **物理块(页框)**: 
    - 把**内存空间**分成与**页面相同大小**的若干个存储块
- 分配时**主存块可以不连续**; 而**页内逻辑地址是连续的**
- **分页存储器的逻辑地址**: 页号和页内地址(位移量)
    - 假设地址总长度为15位，其中页号占5位，页内地址占10位;那么逻辑地址可有32页，编号为0－31;页内地址占10位，则块的大小为1024个字节。编号为0－1023。
    - 若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得:
    $$P=INT[A/L]$$
    $$d=A mod(L)$$
### 页表(地址变换机构)
- 作用：实现**逻辑地址**到**物理地址**的转换(将**逻辑地址中的页号**转换为**内存中的物理块号**)
- 地址转换的公式为：**绝对地址＝块号*块长+页内地址**
<img src="..\img\OS\页表变换地址.png" width="70%" height="70%" align="middle">

- 页表控制寄存器--系统中只有一个

### 引入快表(TLB)的地址变换机构
- 引入原因：由于页表是存放在内存中的，这使CPU每次要存取一个数据时，都要两次访问内存。
    - 第一次是访问内存中的**页表**，从中找到该页的物理块号，将此块号与页内偏移量w拼接以形成物理地址
    - 第二次访问内存时，才是从第一步所得地址中**获得所需数据**(或向此地址中写入数据)
- TLB是一组相联快速存储，是寄存器，类似**Cache**
- **有效访问时间 = HitR*(TLB+MA) + (1-HitR)*(TLB+2MA)**
- 原理：
    - 程序的地址访问存在局部性
    - 空间局部性(程序多体现为循环、顺序结构)
<img src="..\img\OS\具有块表的页表地址变换.png" width="70%" height="70%" align="middle">

### 两级和多级页表 
- 引入原因: 现代的大多数计算机系统，都支持非常大的逻辑地址空间。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。并且为连续的。
- 解决方法：
    - 采用**离散分配方式**来解决难以找到一块连续的大内存空间的问题；
    - 将**当前需要的部分页表项调入内存**，其余的**页表项驻留在磁盘上**，需要时再调入
#### 两级页表
- 将页表也进行分页的办法，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，即依次为0页，1页，…，n页。可以离散地将各个页面分别放在不同的物理块中
- 外层页表：为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table)，在每个页表项中记录了页表页面的物理块号。
## 基本分段存储管理方式 
- 引入：为了满足用户和程序员的下述一系列需要：
    - **方便编程**：通常采用分段，汇编。。。
    - **信息共享**：通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的；
        - 比如，共享某个例程和函数。而在分页系统中的每一页都只是存放信息的物理单位，其本身并无完整的意义，因而不便于实现信息共享；然而段却是信息的逻辑单位。
    - **信息保护**
    - **动态增长**
    - **动态链接**
### 分段
- 内容：
    - 作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。
    - 将程序的地址空间划分为若干个段(segment)，程序加载时，分配其所需的所有段（内存分区），这些段不必连续；物理内存的管理采用动态分区。需要CPU的硬件支持。
- 优点：
    - 没有内碎片，外碎片可以通过内存紧缩来消除
    - 便于改变进程占用空间的大小
### 段表
段表实现从逻辑段到物理内存区的映射。
<img src="..\img\OS\段表变换地址.png" width="70%" height="70%" align="middle">

### 分页和分段的主要区别
#### 相同点
- 都采用离散分配方式；
- 都要通过地址映射机构来实现地址变换
#### 不同点
- **分页是出于系统管理**的需要，**分段是出于用户应用**的需要
    - 一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。
- 页大小是系统固定的，而段大小则通常不固定
- **逻辑地址表示**：
    - 分页是一维的，各个模块在链接时必须组织成同一个地址空间；
    - 分段是二维的，各个模块在链接时可以每个段组织成一个地址空间
- 通常**段比页大**，因而段表比页表短，可以缩短查找时间，提高访问速度。
- 分页系统能有效地**提高内存利用率**，而分段系统则能很好地**满足用户需要**。
## 段页式存储管理方式 
### 优点：
- 段页式既具有分段系统**便于实现、分段可共享、易于保护、可动态链接**等一系列优点；
- 也具有分页系统那样很好地**解决内存的外部碎片问题**，以及为各个分段**可离散地**分配内存等问题
### 基本原理 
把用户程序分成若干段，再把每个段分成若干页
<img src="..\img\OS\段页式地址变换.png" width="70%" height="70%" align="middle">

- 在段页式系统中，为了获取一条指令或数据，须3次访问内存。
    - 第一次：访问内存中的段表，从中取得页表地址；
    - 第二次：访问内存中的页表，从中取出该页所在的物    理块号，同时和页内地址相加求出物理地址；
    - 第三次：从地址中取出指令或数据；

## 虚拟存储器的基本概念 
- 引入原因：
    - 作业很大：
    其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行；
    - 大量作业要求运行：
    但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量的作业留在外存上等待。
- 解决方法：
    - 从**物理上**增加内存容量。
    - 从**逻辑上**扩充内存容量。这正是**虚拟存储技术**所要解决的主要问题。
### 定义
- 所谓**虚拟存储器**，是指具有**请求调入功能**和**置换功能**，能从**逻辑上**对**内存容量加以扩充**的一种存储器系统。
- 其**逻辑容量**受限于计算机的**地址结构**和**可用磁盘容量**，其运行速度**接近于内存速度**。 
### 基本原理
- 在程序装入时，不必将其全部读入到内存，而只需**将当前需要执行的部分页或段读入到内存**，就可让程序开始执行。
- 在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为**缺页或缺段**），则由处理器通知操作系统将相应的页或段**调入到内存**，然后继续执行程序。
- 另一方面，操作系统将内存中**暂时不使用的页或段调出保存在外存**上，从而腾出空间存放将要装入的程序以及将要调入的页或段。只需程序的一部分在内存就可执行。
### 优点
- **大程序**：可在较小的可用内存中执行较大的用户程序；
- **大的用户空间**：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)
- **并发**：可在内存中容纳更多程序并发执行；
- **易于开发**：与覆盖技术比较，不必影响编程时的程序结构
### 实现方式
- 虚拟存储器的实现，是建立在**离散分配**的存储管理方式基础上
- 常见方法有：
    - 分页请求系统 
    - 分段请求系统


## 请求分页存储管理方式 





## 页面置换算法 
## 请求分段存储管理方式 

# I/O设备管理

# 文件管理

