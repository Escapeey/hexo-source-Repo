---
title: OS-进程管理
tags: 操作系统
category: 操作系统
abbrlink: '18614213'
date: 2024-01-05 16:43:12
---
# 进程的描述与控制
## 程序的顺序执行及其特征
程序顺序执行时的特征:
- **顺序性**: 按照程序结构所指定的次序
- **封闭性**: 运行时候独占处理机资源，运行结果不受外界影响
- **可再现性**: 初始条件相同，结果相同

## 程序的并发执行及其特征
**定义**：程序的并发执行是指一组在逻辑上互相独立的程序或程序段在执行时间上客观上互相重叠，即一个程序或程序段的执行尚未结束，另一个程序（段）的执行已经开始的执行方式
程序并发执行时的特征:
- **间断性(相互制约性)**:－ “走走停停”，一个程序可能走到中途停下来，失去原有的时序关系；
- **失去封闭性**：多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变, 致使程序的运行已失去了封闭性。
- **不可再现性**：程序在并发执行时，由于失去了封闭性，也将导致失去其可再现性

## 进程
### 进程的定义
- 简：进程是程序的一次执行；
- 详：一个具有一定独立功能的**程序**在一个**数据集合**上的一次**动态执行**过程
- 进程是系统进行**资源分配和调度**的一个**独立单位**
### 进程的特征
- **动态性**:
    - 进程是程序产生的：创建->运行->消亡
    - 进程在生命周期中在三种基本状态之间转换
- **独立性**:
    各进程的**地址相互独立**，除非采用进程间通信手段
- **并发性**:
    多个进程实体同时存于内存中，能在一段时间内并发进行
- **异步性**:
    每个进程都以其相对独立的不可预知的速度向前推进
- **结构化**:
    进程 = 代码块 + 数据块 + **PCB**
### 进程的组成
**进程 = 程序 + 数据 + 进程控制块PCB**
- **程序**是进程的不可缺少的组成部分；如果一个程序段允许被共享，则它应该是可重入的，或纯代码段
- **数据**是进程处理的对象
- **进程控制块**是进程的**控制结构**，包含了进程的**描述信息**、**控制信息**和**资源信息**以及**现场保护区**，是进程的<font color=red>**唯一标识**</font>，系统通过PCB管理和控制进程。

### 进程控制块PCB
- 进程控制块是由OS维护的用来记录进程相关信息和管理进程而设置的一个专门的**数据结构**
- PCB结构的全部或部分**常驻内存**；
- PCB随进程的创建而填写，随进程的撤消而释放,有生命周期；
- 系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志
- 进程与PCB是一一对应的
- **OS是根据PCB来对并发执行的进程进行控制和管理的。**
- **所谓创建进程是指创建进程实体中的PCB，撤销亦如此。**

#### PCB的内容
- **进程标识符**: 
    - 内部进程标识符(process ID)，唯一，通常是一个整数
    - 进程名(外部标识符)，通常基于可执行文件名（不唯一）
    - 用户标识符(user ID)；进程组关系(process group)
- **进程调度信息**：
    进程状态、进程优先级、资源信息等
- **处理机状态**：
    寄存器值（通用、程序计数器PC、状态PSW，地址包括栈指针）
- **进程控制信息**:
    - 当前状态；
    - 优先级(priority)；
    - 代码执行入口地址；
    - 程序的外存地址；
    - 运行统计信息（执行时间、页面调度）；
    - 进程间同步和通信；阻塞原因

#### PCB的组织方式
- **链表**：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表
    - 各状态的进程形成不同的链表：就绪链表、阻塞链表
- **索引表**：同一状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表
    - 各状态的进行形成不同的索引表：就绪索引表、阻塞索引表
### 进程与程序的区别
- 进程是动态的，程序是静态的：炒菜菜谱
- 进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存。
- 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）。
- 进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。
- 进程具有并行特征，程序没有。
- 进程是竞争计算机资源的基本单位。
## 进程的状态及其转换
### 进程的三种基本状态
- **就绪状态(Ready)**：已分配到**除CPU以外**的所有必要的资源，只要能再获得处理机，便可立即执行的状态。多个排成一队称为就绪队列。 
- **执行状态(Running)**：指进程已获得处理机，其程序正在执行;
    - 在单处理机系统中，只能有一个进程处于执行状态;
    - 在多处理机系统中，则可能多个进程处于执行状态。  
- **阻塞状态(Blocked)**：进程因**发生某事件**(如请求I／O、申请缓冲空间等)而暂停执行时的状态，亦即进程的执行受到阻塞，故称这种暂停状态为阻塞状态，有时也称为“等待”状态或“睡眠”状态。
    - 通常将处于阻塞状态的进程排成一个队列，称为阻塞队列。在有的系统中，按阻塞原因的不同而将处于阻塞状态的进程排成多个队列。
### 进程的三种基本状态转换
<img src="..\..\img\OS\进程三状态.png" width="50%" height="70%" align="middle">

- **就绪->运行**：调度程序选择一个新的进程运行
- **运行->就绪**：
    - 运行进程用完了时间片
    - 运行进程被中断，因为一高优先级进程处于就绪状态
- **运行->等待**：当一进程等待某一事件的发生时，如
    - 请求系统服务
    - 无新工作可做
- **等待->就绪**：当所等待的事件发生时

### 进程的五状态进程转换
<img src="..\..\img\OS\进程五状态.png" width="50%" height="70%" align="middle">

- **创建状态(New)**：创建新状态
    - OS 已完成为创建一进程所必要的工作
        - 已构造了进程标识符
        - 已创建了管理进程所需的表格
- **终止状态(Exit)**
    - 终止后进程移入该状态
    - 它不再有执行资格
    - 表格和其它信息暂时保留
    - 实用程序为了分析性能和利用率，可能要提取程序的历史信息
### 带挂起的进程转换模型
#### 新增状态
- **就绪挂起状态(Ready,suspend)**：进程在外存，但只要进入内存，即可运行；
- **阻塞挂起状态(Blocked,suspend)**：进程在外存并等待某事件的出现；
#### 新增事件
- **挂起(Suspend)**：把一个进程从内存转到外存；可能有以下几种情况：
    - **阻塞到阻塞挂起**：没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种转换，以纳入新进程或运行就绪进程；
    - **就绪到就绪挂起**：当有高优先级阻塞（系统认为会很快就绪的）进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程；
    - **运行到就绪挂起**：对抢先式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态；
- **激活(Activate)**：把一个进程从外存转到内存；可能有以下几种情况：
    - **就绪挂起到就绪**：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换；
    - **阻塞挂起到阻塞**：当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转为阻塞状态；较少出现。
- **事件出现(Event Occurs)**：进程等待的事件出现；如：操作完成、申请成功等；可能的情况有：
    - **阻塞到就绪**：针对内存进程的事件出现；
    - **阻塞挂起到就绪挂起**：针对外存进程的事件出现；
- **收容(Admit)**：收容一个新进程，进入就绪状态或就绪挂起状态。
- **各种状态->退出**：被父进程终止或父进程本身终止。


#### 挂起进程目的是:
- **提高处理机效率**：就绪进程表为空时，OS将阻塞进程从内存中“挂起”到磁盘的“挂起队列”，再从该队列选另一进程进入内存，或接受一个新进程的请求。
- **为运行进程提供足够内存**：资源紧张时，暂停某些进程，如：CPU繁忙（或实时任务执行）,内存紧张
- **用于调试**：在调试时，挂起被调试进程（从而对其地址空间进行读写）
#### 单挂起进程模型
<img src="..\..\img\OS\单挂起进程模型.png" width="50%" height="70%" align="middle">

#### 双挂起进程模型
<img src="..\..\img\OS\双挂起进程模型.png" width="50%" height="70%" align="middle">

## 进程控制的功能
### 原语(primitive)
- 由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割－－要么全都完成，要么全都不做。许多系统调用就是原语。
### 进程创建原语
子进程的创建的3种形式
|  | 产生新进程 | 不产生新进程 |
|:-:|:-------:|:-----------:|
|复制现有进程的上下文|**fork**(新进程的系统上下文会有不同)|   |
|加载程序|**spawn**(创建新进程并加载新程序) |**exec**(加载新程序并覆盖自身)|
### 进程撤销原语
**Destroy**
- 释放资源：
    - 释放内外存空间
    - 关闭所有打开文件
    - 释放共享内存段和各种锁定lock
### 进程阻塞原语
**Block**
- 阻塞原因：当进程期待的某事件尚未出现时，该进程调用阻塞原语把自己阻塞起来
- 进程的阻塞是进程自身的一种主动行为
### 进程唤醒原语
**Wakeup**
- 唤醒原因：
    - 进程等待的事件发生，等待队列中的进程唤醒。
- 唤醒进程的两种方法：
    - **由系统进程唤醒**: 系统进程统一控制事件的发生，并将“事件发生”这一消息通知等待进程。等待的是公共资源。
    - **由事件发生进程唤醒**: 事件发生进程与被唤醒的进程是合作关系，等待私有资源。
### 进程挂起原语
**Suspend**
- 引起进程挂起的事件:
    - 用户进程请求将自己挂起;
    - 或父进程请求将自己的某个子进程挂起，
    - 系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。
### 进程激活原语
**Active**
- 进程的激活过程
    - 系统将利用激活原语active( )将指定进程激活。 激活原语先将进程从外存调入内存，检查该进程的现行状态，若是就绪挂起，便将之改为活动就绪；若为阻塞挂起便将之改为活动阻塞。


# 进程同步
## 1.一组并发进程执行时存在两种相互制约关系： 
- **进程互斥** (打印机)
    - **资源共享关系**（间接相互制约关系） 
    - 进程本身之间**不存在直接联系**。
    - 例如:在仅有一台打印机的系统中，有两个进程A和B，如果在A进程提出打印请求时，系统已将打印机分配给进程B，则系统让A进程等待，直至B将打印机用完并释放后，系统才将打印机分配给进程A。
- **进程同步** (接力棒)
    - **相互合作关系**（直接相互制约关系）
    - 进程本身之间**存在着相互制约的关系**。
    - 例如：有一输入进程A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程B因不能获得所需数据而等待。当进程A把数据送入缓冲时，便应向进程B发送一信号，将它唤醒
## 2.临界资源
- 临界资源: 在一段时间内只允许**一个进程访问**的资源。诸进程间应采取**互斥方式**，实现对资源的共享。
- 共享变量，打印机 等均属于此类资源。

## 3.临界区
### 临界区的定义与进入
- **临界区**(critical section)：
    在每个进程中访问临界资源的那段代码
- **进入区**：
    在临界区前面增加一段用于进行临界资源检查的代码
- **退出区**：
    将临界区正被访问的标志恢复为未被访问的标志。
- **剩余区**：其余部分。
### 使用临界区遵循的原则
- **空闲则入**：其他进程均不处于临界区；
- **忙则等待**：已有进程处于其临界区；
- **有限等待**：等待进入临界区的进程不能"死等"；
- **让权等待**：不能进入临界区的进程，应释放CPU(如转换到阻塞状态)
### 解决诸进程互斥进入临界区的方法
- 硬件同步机制
- 软件同步机制

## 4.硬件同步机制
目的：解决诸进程互斥进入临界区。
目前许多计算机已提供了一些特殊的硬件指令来解决临界区问题。
- 关中断；
    - 关中断是实现互斥的最简单的方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。
    - 关中断的方法存在许多缺点：
        - 滥用关中断权力可能导致严重后果；
        - 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；
        - 关中断方法也不适用于多CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。
- 利用Test-and-Set指令实现互斥；
- 利用Swap指令实现进程互斥；

## 5.软件同步机制(进程互斥的软件方法)
### 利用信号量机制实现进程互斥

## 6.管程(monitor)

# 进程通信及线程

# 处理机调度与死锁--完成进程状态的转换