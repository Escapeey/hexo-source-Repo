---
title: 编译原理-自顶向下的语法分析
date: 2024-05-21 13:28:07
tags:
---
# 语法分析概述
语法分析的主要工作是根据**源语言**的文法，判别某个**单词序列**是否是源语言的一个**句子**
- **语言**是满足一定**组成规则**的**句子集合**
- **句子**是满足一定**组成规则**的**单词序列**
- **单词**则是满足一定**组成规则**的**字符串**
- 这些**组成规则**就是文法中的**产生式**

## 两种方式
- **产生句子**的方式：从文法的开始符号开始，逐步**推导**出这个单词序列，也称为**自顶向下**的语法分析
    - 递归子程序法
    - 预测分析法(LL(1))
- **识别句子**的方式：逐步将构成程序的单词序列**归约**为文法的**开始符号**，也称为**自底向上**的语法分析
    - 算符优先分析法
    - LR(0)、SLR(1)、LR(1)、LALR(1)

无论是自顶向下还是自底向上，语法分析器都是**自左到右**地扫描输入**单词序列**，每次读入一个单词，针对输入单词序列**建立一颗语法分析树**
不同的分析方法对应着**不同的构建树的方式**

## 语法分析时的恢复策略
- **紧急方式恢复策略**：丢弃输入记号，直到发现某个指定的同步记号为止。同步记号通常是定界符（分号或end标记），标志着一条新语句的开始。
- **短语级恢复策略**：对剩余输入做局部纠正

# 自顶向下的语法分析面临的问题
- **基本思想**:
    - 从文法的开始符号出发，寻求所给的输入符号串的一个**最左推导**。
    - 即从树根S开始，构造所给输入符号串的**语法树**
- 自顶向下分析实际上是一种**试探性**的过程，可能导致分析效率极低甚至失败
- 面临三种问题
## 二义性问题
解决方法1：改造文法，引入新的文法变量
解决办法2：根据优先级关系，保证**高优先级运算符优先**的原则

## 左递归引起的无穷推导问题
- **左递归**: 如果存在推导 $A \Rightarrow^+ \alpha A\beta$，则称文法G是递归的，当 $\alpha = \epsilon$ 时称之为左递归；
- **间接左递归**: 如果 $A \Rightarrow^+ \alpha A\beta$至少需要两步推导，则称文法G是间接递归的，当 $\alpha = \epsilon$ 时称之为间接左递归；
- **直接左递归**: 如果文法G中存在形如 $A \rightarrow \alpha A\beta$的产生式，则称文法G是直接递归的，当 $\alpha = \epsilon$ 时称之为直接左递归。

## 回溯问题
- 文法中每个语法变量A的产生式右部称为A的**候选式**
- 如果A有多个候选式存在**公共前缀**，则自顶向下的语法分析程序将无法根据当前输入符号准确地选择用于推导的产生式，只能试探。
- 当试探不成功时就需要退回到上一步推导，看A是否还有其它的候选式，这就是**回溯**(backtracking)。

我们将采用提取左因子的方法来改造文法，以便减少推导过程中回溯现象的发生
当然，单纯通过提取左因子无法彻底避免回溯现象的发生。

# 对上下文无关文法的改造
## 消除二义性
改造的方法就是通过**引入新的语法变量**等，使文法含有更多的信息。
### 二义性举例：
<img src="..\..\img\CompilerPrinciples\二义性文法举例.png" width="100%" height="100%" align="middle">

**分析：**
根据if语句中else与then配对情况将其分为**配对的语句**和**不配对的语句**两类。
上述if语句的文法没有对这两个不同的概念加以区分，只是简单地将它们都定义为\<stmt\>，从而导致该文法是二义性的
**解决：**
<img src="..\..\img\CompilerPrinciples\二义性文法举例解决.png" width="100%" height="100%" align="middle">

## 消除左递归
### 消除直接左递归
- 直接左递归的消除(转换为右递归)
- 引入新的变量$A'$ ，将左递归产生式$A\rightarrow A\alpha | \beta$ 替换为 $A\rightarrow \beta A'$ $A' \rightarrow \alpha A' | \epsilon$ 
<img src="..\..\img\CompilerPrinciples\消除左递归1.png" width="100%" height="100%" align="middle">

### 具体做法
<img src="..\..\img\CompilerPrinciples\消除左递归2.png" width="100%" height="100%" align="middle">

- 上述方法**只能消除直接**左递归，**无法消除间接**左递归
- 消除**间接左递归**的**基本思想**：为语法**变量编号**，再采用**带入法**将**间接左递归变为直接左递归**，然后采用上述方法来消除直接左递归

### 消除所有左递归
<img src="..\..\img\CompilerPrinciples\消除左递归算法.png" width="100%" height="100%" align="middle">

<img src="..\..\img\CompilerPrinciples\消除左递归算法例子.png" width="100%" height="100%" align="middle">

## 提取左因子（解决回溯问题）
**方法：**
<img src="..\..\img\CompilerPrinciples\提取左因子.png" width="100%" height="100%" align="middle">
提取左因子并不能完全消除回溯

**例子：**
<img src="..\..\img\CompilerPrinciples\提取左因子例子.png" width="100%" height="100%" align="middle">
 
# LL(1)文法
- **不确定**的自顶向下分析
    - 分析需要回溯，导致分析存在不确定性
    - 代价高、效率低，实际中几乎不被采用
- **确定**的自顶向下分析
    - 不能处理所有文法，这里讨论什么样的文法可以进行确定的自顶向下分析
- LL(1)文法就是可以**彻底消除回溯**实现**确定的**自顶向下分析的文法
- 文法要求：
    - 无二义性
    - 无左递归
    - 任意一个语法变量A的各个候选式所能推导出的**第一个终结符**必须各不相同



# 预测分析法

# 递归下降分析法







