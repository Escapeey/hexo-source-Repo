---
title: 排序算法
date: 2024-04-01 16:36:10
tags: Algorithm
category: Algorithm
---

[参考博客](https://blog.csdn.net/alzzw/article/details/98100378)

<img src="../../img/Algorithm/排序算法分类.png" width="100%" height="100%">

# 复杂度
<img src="../../img/Algorithm/排序算法复杂度对比.png" width="100%" height="100%">

- 稳定性：
    - 指待排序的序列中有两元素相等,排序之后它们的先后顺序不变.
    - 也可以理解为一切皆在掌握中,元素的位置处在你在控制中.而不稳定算法有时就有点碰运气,随机的成分.

# BubbleSort
```C++
void BubbleSort(vector<int>& vec, int l, int r){
    if(l < r){
        for(int i=0; i<r; i++){
            if(vec[i] > vec[i+1])
                swap(vec[i], vec[i+1]);
        }
    }
    BubbleSort(vec, l, r-1);
}
```

# SelectionSort
```C++
void SelectionSort(vector<int>& vec, int n){
    while(n > 1){
        int max, pos = vec[0], 0;
        for(int i=0; i<n; i++){
            if(max < vec[i]){
                max = vec[i];
                pos = i;
            }
        }
        swap(vec[pos], vec[n-1];)
        n--;
    }
}
``` 

# InsertionSort
```C++
void InsertionSort(vector<int>& vec, int n){
    for(int i=1; i<n; i++){
        int key, j = vec[i], i;
        while(vec[j-1] > key){
            vec[j] = vec[j-1];
            j--;
            if(j==0)
                break;
        }
        vec[j] = key;
    }
}
```

# ShellSort
```C++
void ShellSort(vector<int>& vec, int n){
    for(int interval=4; interval>0; interval/=2){
        for(int i=interval; i<n; i++){
            int key, j = vec[i], i;
            while(vec[j-interval] > key){
                vec[j] = vec[j-interval];
                j -= interval;
                if(j<0)
                    break;
            }
            vec[j] = key;
        }
    }
}
```

# MergeSort
```C++
void Merge(vector<int>& vec, int l, int mid, int r){
    vector<int> helper(vec);
    int lp, rp, cp = l, mid+1, l;
    while(lp<=mid && rp<=r){
        if(helper[lp] >= helper[rp]){
            vec[cp++] = helper[rp++];
        }else{
            vec[cp++] = helper[lp++];
        }
    }
    while(lp <= mid){
        vec[cp++] = helper[lp++];
    }
}
void MergeSort(vector<int>& vec, int l, int r){
    if(l < r){
        int mid = (l+r)>>1;
        MergeSort(vec, l, mid);
        MergeSort(vec, mid+1, r);
        Merge(vec, l, mid, r);
    }
}
```

# QuckSort
```C++
int partition(vector<int>& vec, int l, int r){
    //三点取中心值 作为 pivot
    int midIndex = (l + r)>>1;
    if(vec[l] > vec[r])
        swap(vec[l], vec[r]);
    if(vec[l] > vec[midIndex])
        swap(vec[l], vec[midIndex]);
    if(vec[midIndex] > vec[r])
        swap(vec[midIndex], vec[r]);
    swap(vec[l], vec[midIndex]);

    int pivot, lp, rp = vec[l], l+1, r;
    while(lp <= rp){
        while(vec[lp] <= pivot && lp<=rp)
            lp++;
        while(vec[rp] > pivot && lp<=rp)
            rp--;
        if(lp < rp)
            swap(vec[lp], vec[rp]);
    }
    swap(vec[rp], vec[l]);
    return rp; //此时 lp==rp
}
void QuckSort(vector<int>& vec, int l, int r){
    if(l < r){
        int p = partition(vec, l, r);
        QuckSort(vec, l, p);
        QuckSort(vec, p+1, r);
    }
}
```

# HeapSort
```C++
void heapify(vector<int>& vec, int i, int n){
    int lp, rp = 2*i+1, 2*i+2;
    int largestId = i;
    if(lp < n && vec[largestId] < vec[lp]) 
        largestId = lp;
    if(rp < n && vec[largestId] < vec[rp])
        largestId = rp;
    if(largestId != i){
        swap(vec[largestId], vec[i]);
        heapify(vec, n, largestId);
    }
}
void HeapSort(vector<int>& vec){
    int n = vec.size();
    // 建堆
    for(int i=n/2-1; i>=0; i--){
        heapify(vec, n, i);
    }
    //排序
    for(int i=n-1; i>0; i--){
        swap(vec[i], vec[0]);
        heapify(vec, 0, i); 
        // 这里的i是堆去掉排序好的元素后的长度
    }
}
```

# BucketSort
```C++
//设置10个桶
int N = 10;
void BucketSort(vector<int> &vec){
    int n = vec.size();
    vector<vector<int>> bucket(N);
    for(int i = 0; i < n; i++)
	    bucket[vec[i] / 10].push_back(vec[i]);
    int k = 0;
    for(int i = 0; i < N; i++){
    	//对每个桶进行排序
    	sort(bucket[i].begin(), bucket[i].end());
    	for(int j=0; j<bucket[i].size(); j++)
    	    vec[k++] = bucket[i][j];//放入原数组	
    }
    vector<vector<int>>().swap(bucket); //释放空间
}
```
# RadixSort
```C++
int get_max(vector<int>& vec, int n)
{
    int max = vec[0];
    for (int i = 1; i < n; i++)
        if (vec[i] > max)
            max = vec[i];
    return max;
}

// 对数组按照"某个位数"进行排序(桶排序)
// exp -- 指数 0, 10, 100, ...
void count_sort(vector<int>& vec, int n, int exp)
{
    vector<int> output(n);             // 存储"被排序数据"的临时数组
    vector<int> buckets(10, 0);
    // 将数据出现的次数存储在buckets中
    for (int i = 0; i < n; i++)
        buckets[(vec[i]/exp)%10]++;
    // 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。
    for (int i = 1; i < 10; i++)
        buckets[i] += buckets[i - 1];
    // 将数据存储到临时数组output中
    for (int i = n - 1; i >= 0; i--)
    {
        output[buckets[(vec[i]/exp)%10] - 1] = vec[i];
        buckets[(vec[i]/exp)%10]--;
    }
    // 将排序好的数据赋值给vec
    vec.swap(output);
}

void RadixSort(vector<int>& vec, int n)
{
    int max = get_max(vec, n);    
    // 从个位开始，对数组a按"指数"进行排序
    for (int exp = 1; max/exp > 0; exp *= 10)
        count_sort(vec, n, exp);
}
```
